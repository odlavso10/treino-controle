<!DOCTYPE html>
<html lang="pt-br">\>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jogo de Reação – Controle PlayStation</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121933; --accent:#7c9cff; --good:#20c997; --bad:#ff6b6b; --text:#e8ecff; --muted:#a7b1d4; --gold:#ffcf40;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,Helvetica,sans-serif;background:radial-gradient(1200px 600px at 70% -10%,#1a2358 0%, #0b1020 50%);color:var(--text);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .app{width:min(1240px,100%);}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-weight:800;margin:0;font-size:clamp(20px,3.8vw,34px);letter-spacing:0.2px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.08);backdrop-filter: blur(6px); border-radius:20px;padding:18px}
    .grid{display:grid;grid-template-columns: 1.2fr 1fr;gap:18px}
    @media(max-width:960px){.grid{grid-template-columns: 1fr}}

    .target{position:relative;display:grid;place-items:center;aspect-ratio:16/10;border-radius:16px;background:linear-gradient(180deg,rgba(124,156,255,0.12),rgba(124,156,255,0.05));border:1px dashed rgba(124,156,255,0.35);overflow:hidden}
    .target .big{display:flex;align-items:center;gap:18px}
    .icon{width:94px;height:94px;border:4px solid var(--accent);border-radius:20px;display:grid;place-items:center;}
    .shape{font-weight:900;font-size:52px;line-height:1}
    .shape.triangle{border:4px solid #36e3a0;border-radius:10px; width:56px;height:56px; clip-path: polygon(50% 8%, 6% 92%, 94% 92%)}
    .shape.circle{border:4px solid #ff4da6;border-radius:50%;width:56px;height:56px}
    .shape.cross{position:relative;width:56px;height:56px}
    .shape.cross::before,.shape.cross::after{content:"";position:absolute;left:50%;top:50%;width:10px;height:56px;background:#61d0ff;border-radius:6px;transform:translate(-50%,-50%) rotate(45deg)}
    .shape.cross::after{transform:translate(-50%,-50%) rotate(-45deg)}
    .shape.square{border:4px solid #77c0ff;border-radius:8px;width:56px;height:56px}

    .label{font-size:40px;font-weight:800;letter-spacing:0.5px}
    .status{display:flex;gap:12px;align-items:center;margin-top:8px;color:var(--muted)}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);font-size:12px}

    .controls{display:flex;gap:10px;flex-wrap:wrap}
    button,select{appearance:none;border:1px solid rgba(255,255,255,0.16);background:rgba(255,255,255,0.06);color:var(--text);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    button:hover{background:rgba(255,255,255,0.12)}
    button.primary{background:linear-gradient(180deg,var(--accent),#5d7dff);border-color:transparent;color:white}
    button.good{background:linear-gradient(180deg,var(--good),#1fb185);border-color:transparent}
    button.bad{background:linear-gradient(180deg,var(--bad),#e05b5b);border-color:transparent}

    .side{display:grid;gap:16px}

    .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .stat{padding:14px;border-radius:14px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08)}
    .stat .v{font-size:28px;font-weight:800}
    .stat .k{font-size:12px;color:var(--muted)}

    .list{display:flex;flex-wrap:wrap;gap:8px}
    .chip{font-size:12px;padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.14);color:#dfe6ff;background:rgba(255,255,255,0.04)}
    .chip.on{background:rgba(124,156,255,0.18);border-color:rgba(124,156,255,0.48)}

    .log{height:160px;overflow:auto;padding:10px;border-radius:12px;background:#0c132a;border:1px solid rgba(255,255,255,0.08);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;line-height:1.4}
    .hint{color:var(--muted);font-size:13px}
    .ok{color:var(--good)} .err{color:var(--bad)}

    /* Combo UI */
    .comboWrap{position:absolute;left:16px;bottom:16px;display:flex;flex-direction:column;gap:6px}
    .combo{font-weight:900;font-size:28px}
    .combo.big{font-size:40px}
    .flash{position:absolute;inset:0;opacity:0;pointer-events:none}
    .flash.success{background:rgba(32,201,151,0.18)}
    .flash.error{background:rgba(255,107,107,0.2)}
    .anim-flash{animation: flash .18s ease}
    @keyframes flash{from{opacity:1} to{opacity:0}}
    .anim-pop{animation: pop .25s ease}
    @keyframes pop{0%{transform:scale(1)} 50%{transform:scale(1.12)} 100%{transform:scale(1)}}
    .badge{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);font-size:12px}
    .record{color:var(--gold);font-weight:800}

    /* Timer HUD (T3) */
    .timerHUD{position:absolute;right:14px;top:14px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.35);border:1px solid rgba(255,255,255,0.18);font-weight:800}

    /* Leaderboard */
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.08);font-size:13px}
    th{text-align:left;color:#cfd8ff;font-weight:700}
    tbody tr:nth-child(1) td{background:linear-gradient(90deg, rgba(255,207,64,0.12), transparent)}
    .lb-tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .tab{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.04);cursor:pointer}
    .tab.active{background:rgba(124,156,255,0.18);border-color:rgba(124,156,255,0.48)}

    /* End Screen */
    .overlay{position:absolute;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center}
    .endcard{width:min(540px,92%);background:rgba(17,24,56,0.9);border:1px solid rgba(255,255,255,0.12);border-radius:18px;padding:20px}
    .endcard h2{margin:0 0 10px 0}
    .endgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin:12px 0}
    .enditem{padding:12px;border-radius:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1)}
    .cta{display:flex;gap:10px;justify-content:flex-end}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Jogo de Reação – Controle PlayStation</h1>
      <div class="controls">
        <button id="btnConnect" class="primary">Conectar controle</button>
        <button id="btnStart" class="good">Iniciar</button>
        <button id="btnStop" class="bad">Parar</button>
      </div>
    </header>

    <div class="grid">
      <section class="card target">
        <div id="flashSuccess" class="flash success"></div>
        <div id="flashError" class="flash error"></div>
        <div id="timerHUD" class="timerHUD">∞</div>
        <div class="big">
          <div id="icon" class="icon">
            <div id="shape" class="shape"></div>
          </div>
          <div>
            <div id="label" class="label">Pronto?</div>
            <div class="status">
              <span class="pill" id="padStatus">Sem controle</span>
              <span class="pill" id="roundInfo">—</span>
              <span class="pill" id="feedback">Aguardando…</span>
              <span class="pill" id="levelHUD">Nível: Fácil</span>
            </div>
          </div>
        </div>
        <div class="comboWrap">
          <span class="badge">🔥 Combo</span>
          <div id="comboText" class="combo">x0</div>
          <div id="comboSpecial" class="combo big" style="display:none"></div>
        </div>

        <!-- End Screen Overlay -->
        <div id="overlay" class="overlay">
          <div class="endcard">
            <h2>Fim da Sessão</h2>
            <div class="hint" id="endLevel">Nível: — | Duração: —</div>
            <div class="endgrid">
              <div class="enditem"><strong>Média</strong><div id="endAvg">—</div></div>
              <div class="enditem"><strong>Melhor</strong><div id="endBest">—</div></div>
              <div class="enditem"><strong>Melhor Combo</strong><div id="endCombo">—</div></div>
              <div class="enditem"><strong>Leaderboard</strong><div id="endLB">—</div></div>
            </div>
            <div class="cta">
              <button id="btnRestart" class="good">Reiniciar</button>
              <button id="btnClose" class="bad">Voltar / Fechar</button>
            </div>
          </div>
        </div>
      </section>

      <aside class="side">
        <section class="card">
          <strong>Dificuldade (D3 – Híbrido)</strong>
          <div style="display:flex;gap:10px;align-items:center;margin-top:8px">
            <select id="levelSelect">
              <option value="easy">Fácil</option>
              <option value="medium">Médio</option>
              <option value="hard">Difícil</option>
            </select>
            <span class="hint">Troca permitida apenas com o jogo parado (T1).</span>
          </div>
        </section>

        <section class="card">
          <strong>Alvos incluídos</strong>
          <div id="pool" class="list" style="margin-top:8px"></div>
          <div class="hint" style="margin-top:8px">Clique para (des)ativar. <b>OBS:</b> ao <b>Iniciar</b>, o nível escolhido substitui automaticamente esta seleção.</div>
        </section>

        <section class="card stats">
          <div class="stat"><div class="v" id="statLast">—</div><div class="k">Última reação</div></div>
          <div class="stat"><div class="v" id="statAvg">—</div><div class="k">Média</div></div>
          <div class="stat"><div class="v" id="statBest">—</div><div class="k">Melhor</div></div>
        </section>

        <section class="card">
          <strong>Registro</strong>
          <div id="log" class="log"></div>
        </section>

        <section class="card">
          <strong>Opções</strong>
          <div style="margin-top:8px;display:grid;gap:10px">
            <label>Duração da sessão:
              <select id="sessionSelect">
                <option value="0">Infinito</option>
                <option value="30">30s</option>
                <option value="60" selected>60s</option>
                <option value="90">90s</option>
              </select>
            </label>
            <label>Tempo mínimo entre alvos: <input id="minDelay" type="number" value="600" min="100" max="5000" step="50"> ms</label>
            <label>Tempo máximo entre alvos: <input id="maxDelay" type="number" value="1500" min="200" max="8000" step="50"> ms</label>
            <label>Erro encerra rodada? <input id="endOnError" type="checkbox"></label>
            <label>Teclado como backup? <input id="kbOn" type="checkbox" checked></label>
            <label>Som ligado? <input id="soundOn" type="checkbox" checked></label>
          </div>
          <div class="hint" style="margin-top:6px">Ao iniciar, o nível define automaticamente tempos e alvos.</div>
        </section>

        <section class="card" id="leaderboardCard">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
            <strong>🏆 Leaderboard por nível (R2)</strong>
            <div class="controls"><button id="btnResetLB">Resetar ranking do nível</button></div>
          </div>
          <div class="lb-tabs">
            <button class="tab active" data-lb="easy">Fácil</button>
            <button class="tab" data-lb="medium">Médio</button>
            <button class="tab" data-lb="hard">Difícil</button>
          </div>
          <div class="hint" style="margin-top:6px">Ordena por <b>média</b> (menor→maior). Desempate: <b>maior combo</b>.</div>
          <div style="margin-top:10px;overflow:auto">
            <table>
              <thead><tr><th>#</th><th>Média</th><th>Melhor</th><th>Combo</th><th>Data</th></tr></thead>
              <tbody id="lbBody"><tr><td colspan="5" style="text-align:center;color:var(--muted)">Sem registros ainda</td></tr></tbody>
            </table>
          </div>
        </section>
      </aside>
    </div>
  </div>

  <script>
    // --- Mapeamento de botões físicos (face/ombros) ---
    const BUTTONS = {
      CROSS:   { index: 0, label: '✕ Cross', key:'x', shape:'cross' },
      CIRCLE:  { index: 1, label: '◯ Circle', key:'c', shape:'circle' },
      SQUARE:  { index: 2, label: '□ Square', key:'s', shape:'square' },
      TRIANGLE:{ index: 3, label: '△ Triangle', key:'t', shape:'triangle' },
      L1:      { index: 4, label: 'L1', key:'1' },
      R1:      { index: 5, label: 'R1', key:'2' },
      L2:      { index: 6, label: 'L2', key:'3' },
      R2:      { index: 7, label: 'R2', key:'4' },
    };

    // --- Mapeamento das direções analógicas (virtuais) ---
    const THRESH = 0.45; // T1 sensível
    const ANALOG_KEYS = [
  'L_UP','L_DOWN','L_LEFT','L_RIGHT',
  'R_UP','R_DOWN','R_LEFT','R_RIGHT'
];
    const ANALOG_LABEL = {
  L_UP:'L↑', L_DOWN:'L↓', L_LEFT:'L←', L_RIGHT:'L→',
  R_UP:'R↑', R_DOWN:'R↓', R_LEFT:'R←', R_RIGHT:'R→',
};

    // Dificuldade D3 – pools por nível
    const LEVELS = {
      easy:   { name:'Fácil',  min:900,  max:1500, pool:['CROSS','CIRCLE','SQUARE','TRIANGLE'] },
      medium: { name:'Médio',  min:600,  max:1000, pool:['CROSS','CIRCLE','SQUARE','TRIANGLE','L_UP','L_DOWN','L_LEFT','L_RIGHT','L1','R1','L2','R2'] },
      hard:   { name:'Difícil',min:350,  max:700,  pool:['CROSS','CIRCLE','SQUARE','TRIANGLE', ...ANALOG_KEYS, 'L1','R1','L2','R2'] },
    };

    const DEFAULT_POOL = LEVELS.easy.pool;

    // UI refs
    const padStatus = document.getElementById('padStatus');
    const roundInfo = document.getElementById('roundInfo');
    const feedback = document.getElementById('feedback');
    const label = document.getElementById('label');
    const shape = document.getElementById('shape');
    const poolEl = document.getElementById('pool');
    const logEl = document.getElementById('log');
    const statLast = document.getElementById('statLast');
    const statAvg = document.getElementById('statAvg');
    const statBest = document.getElementById('statBest');
    const btnConnect = document.getElementById('btnConnect');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnResetLB = document.getElementById('btnResetLB');
    const minDelayEl = document.getElementById('minDelay');
    const maxDelayEl = document.getElementById('maxDelay');
    const endOnErrorEl = document.getElementById('endOnError');
    const kbOnEl = document.getElementById('kbOn');
    const soundOnEl = document.getElementById('soundOn');
    const lbBody = document.getElementById('lbBody');
    const flashSuccess = document.getElementById('flashSuccess');
    const flashError = document.getElementById('flashError');
    const comboText = document.getElementById('comboText');
    const comboSpecial = document.getElementById('comboSpecial');
    const levelHUD = document.getElementById('levelHUD');
    const levelSelect = document.getElementById('levelSelect');
    const lbTabs = document.querySelectorAll('.tab');
    const sessionSelect = document.getElementById('sessionSelect');
    const timerHUD = document.getElementById('timerHUD');
    const overlay = document.getElementById('overlay');
    const endLevel = document.getElementById('endLevel');
    const endAvg = document.getElementById('endAvg');
    const endBest = document.getElementById('endBest');
    const endCombo = document.getElementById('endCombo');
    const endLB = document.getElementById('endLB');
    const btnRestart = document.getElementById('btnRestart');
    const btnClose = document.getElementById('btnClose');

    // Estado
    let active = false;
    let targetKey = null; // ex: 'CROSS' ou 'L_UP'
    let showTime = 0;
    let round = 0;
    let results = []; // tempos de reação corretos
    let best = Infinity;
    let combo = 0;
    let bestCombo = 0;
    let level = 'easy';
    let lbView = 'easy'; // aba selecionada no leaderboard
    let endTimerId = null; // setTimeout para encerrar sessão
    let tickId = null; // setInterval para atualizar HUD
    let durSec = 60; // duração selecionada em segundos (0 = infinito)
    let startMs = 0; // timestamp ms do início

    // estados analógicos para borda de movimento
    let lastDirL = null; // ex: 'L_UP', ou null (neutro)
    let lastDirR = null; // ex: 'R_LEFT', ou null

    const pressedPrev = new Map(); // para detecção de borda de botões físicos

    function ms(n){return `${Math.round(n)} ms`}
    function mean(arr){return arr.reduce((a,b)=>a+b,0)/arr.length}

    function log(s, cls){
      const t = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      if(cls) line.className = cls;
      line.textContent = `[${t}] ${s}`;
      logEl.prepend(line);
    }

    function updateStats(last){
      if(last!=null) statLast.textContent = ms(last);
      const avg = results.length ? mean(results) : null;
      statAvg.textContent = avg? ms(avg): '—';
      if(results.length){ best = Math.min(best, ...results); statBest.textContent = ms(best);} else { statBest.textContent='—'; }
    }

    function updateComboUI(){
      comboText.textContent = `x${combo}`;
      comboText.classList.remove('anim-pop');
      void comboText.offsetWidth; // restart anim
      comboText.classList.add('anim-pop');
      const thresholds = [5,10,20,30];
      if(thresholds.includes(combo)){
        comboSpecial.style.display='block';
        comboSpecial.textContent = `COMBO ${combo}!!!`;
        comboSpecial.classList.remove('anim-pop');
        void comboSpecial.offsetWidth;
        comboSpecial.classList.add('anim-pop');
      } else if(combo===0){
        comboSpecial.style.display='none';
      }
    }

    function flash(type){
      const el = type==='ok'? flashSuccess : flashError;
      el.classList.remove('anim-flash');
      void el.offsetWidth;
      el.classList.add('anim-flash');
    }

    function setTargetDisplay(key){
      // Mostra símbolo adequado (S3). Para botões, usa shape; para analógico, usa texto L↑ etc.
      const analog = ANALOG_LABEL[key];
      if(analog){
        // é analógico → mostra texto grande, zera shape
        shape.className = 'shape';
        label.textContent = analog;
      } else {
        const b = BUTTONS[key];
        shape.className = `shape ${b?.shape||''}`;
        label.textContent = b?.label || key;
      }
    }

    function renderTarget(key){
      targetKey = key;
      round++;
      setTargetDisplay(key);
      roundInfo.textContent = `Rodada ${round}`;
      feedback.textContent = 'Vai!';
      feedback.className = 'pill';
      showTime = performance.now();
    }

    function randomFromPool(){
      const pool = getPool();
      if(pool.length===0){ alert('Ative pelo menos 1 alvo na lista.'); return null; }
      const i = Math.floor(Math.random()*pool.length);
      return pool[i];
    }

    function scheduleNext(){
      const min = Number(minDelayEl.value)||600;
      const max = Number(maxDelayEl.value)||1500;
      const delay = Math.max(min, Math.min(max, min + Math.random()*(max-min)));
      setTimeout(()=>{ if(active){ const next=randomFromPool(); if(next) renderTarget(next); } }, delay);
    }

    function applyLevelSettings(){
      const cfg = LEVELS[level];
      // Definir tempos
      minDelayEl.value = cfg.min;
      maxDelayEl.value = cfg.max;
      // Definir pool visual (ativar/desativar)
      Array.from(poolEl.querySelectorAll('.chip')).forEach(chip=>{
        if(cfg.pool.includes(chip.dataset.key)) chip.classList.add('on');
        else chip.classList.remove('on');
      });
      levelHUD.textContent = `Nível: ${cfg.name}`;
      log(`Nível aplicado: ${cfg.name} | ${cfg.min}-${cfg.max} ms | ${cfg.pool.length} alvos`, 'ok');
    }

    function fmtTimeLeft(totalMs){
      if(durSec===0) return '∞';
      const s = Math.max(0, Math.ceil(totalMs/1000));
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }

    function startTimer(){
      clearTimeout(endTimerId); clearInterval(tickId);
      startMs = performance.now();
      timerHUD.textContent = durSec===0 ? '∞' : fmtTimeLeft(durSec*1000);
      if(durSec>0){
        endTimerId = setTimeout(()=>{ endSession('timeup'); }, durSec*1000);
        tickId = setInterval(()=>{
          const elapsed = performance.now() - startMs;
          const left = durSec*1000 - elapsed;
          timerHUD.textContent = fmtTimeLeft(left);
        }, 200);
      } else {
        tickId = setInterval(()=>{ timerHUD.textContent = '∞'; }, 1000);
      }
    }

    function start(){
      if(!navigator.getGamepads){ alert('Seu navegador não suporta Gamepad API. Use Chrome/Edge/Opera/Firefox.'); return; }
      applyLevelSettings();
      durSec = Number(sessionSelect.value||60);
      active = true; round = 0; results=[]; best=Infinity; updateStats();
      combo=0; bestCombo=0; updateComboUI();
      overlay.style.display='none';
      label.textContent = 'Aguardando…'; shape.className = 'shape';
      lastDirL = lastDirR = null;
      startTimer();
      scheduleNext();
      log('Jogo iniciado', 'ok');
    }

    function endSession(reason){
      if(!active) return;
      maybeSaveScore();
      active = false; targetKey=null; label.textContent='Parado'; feedback.textContent='—'; shape.className='shape';
      clearTimeout(endTimerId); clearInterval(tickId);

      const lvl = LEVELS[level];
      const secs = durSec===0 ? 'Infinito' : `${durSec}s`;
      endLevel.textContent = `Nível: ${lvl.name} | Duração: ${secs}`;
      if(results.length){
        const avg = Math.round(mean(results));
        const bst = Math.round(Math.min(...results));
        endAvg.textContent = `${avg} ms`;
        endBest.textContent = `${bst} ms`;
        endCombo.textContent = `x${bestCombo}`;
        const data = readLB();
        const list = (data[level]||[]).slice().sort(sortR2).slice(0,5);
        let pos = '—';
        for(let i=0;i<list.length;i++){
          if(list[i].date === lastSavedDate){ pos = `#${i+1}`; break; }
        }
        endLB.textContent = pos;
      } else {
        endAvg.textContent = endBest.textContent = endCombo.textContent = '—';
        endLB.textContent = '—';
      }
      overlay.style.display='flex';
      log('Sessão encerrada', reason==='timeup'?'ok':'err');
    }

    function stop(){ endSession('manual'); }

    function getPool(){
      return Array.from(poolEl.querySelectorAll('.chip.on')).map(el=>el.dataset.key);
    }

    function buildPoolUI(){
      poolEl.innerHTML = '';
      const keys = [ ...Object.keys(BUTTONS), ...ANALOG_KEYS ];
      keys.forEach(k=>{
        const c = document.createElement('button');
        c.type='button';
        c.className='chip';
        c.dataset.key = k;
        const labelTxt = ANALOG_LABEL[k] || (BUTTONS[k]?.label || k);
        c.textContent = labelTxt;
        if(DEFAULT_POOL.includes(k)) c.classList.add('on');
        c.onclick=()=> c.classList.toggle('on');
        poolEl.appendChild(c);
      });
    }

    // --- Sons (Web Audio) ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let actx = null;
    function ensureAudio(){ if(!actx) actx = new AudioCtx(); }
    function tone(freq=880, dur=0.08, type='triangle', gain=0.05){
      if(!soundOnEl.checked) return;
      ensureAudio();
      const t0 = actx.currentTime;
      const osc = actx.createOscillator();
      const g = actx.createGain();
      osc.type = type; osc.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(gain, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      osc.connect(g).connect(actx.destination);
      osc.start(t0); osc.stop(t0+dur);
    }
    const SFX = {
      ok(){ tone(1200, 0.06, 'triangle', 0.05); tone(1600, 0.06, 'triangle', 0.04); },
      err(){ tone(220, 0.12, 'sawtooth', 0.06); },
      record(){ tone(900, 0.12, 'square', 0.06); setTimeout(()=>tone(1200,0.12,'square',0.06), 90); },
    };

    // --- Gamepad handling ---
    let rafId = null;
    function poll(){
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      let connected = false; let name='';
      for(const pad of pads){
        if(!pad) continue; connected = true; name = pad.id; handlePadButtons(pad); handleAnalog(pad);
      }
      padStatus.textContent = connected? ('Conectado: ' + (name||'Controle')) : 'Sem controle';
      rafId = requestAnimationFrame(poll);
    }

    function handlePadButtons(pad){
      const now = performance.now();
      pad.buttons.forEach((btn, idx)=>{
        const isPressed = btn.pressed || btn.value > 0.5; // triggers analógicos
        const prev = pressedPrev.get(idx) || false;
        if(isPressed && !prev){ // borda de subida
          const entry = Object.entries(BUTTONS).find(([k,v])=>v.index===idx);
          if(entry){ onPressKey(entry[0], now); }
        }
        pressedPrev.set(idx, isPressed);
      });
    }

    function dirFromAxes(x, y, prefix){
  const H = THRESH, V = THRESH;
  const ax = x, ay = y;
  const absX = Math.abs(ax), absY = Math.abs(ay);
  if(absX < H && absY < V) return null; // zona morta
  // Sem diagonais: escolhe o eixo dominante
  if(absX >= absY){
    if(ax > H) return prefix+'_RIGHT';
    if(ax < -H) return prefix+'_LEFT';
  } else {
    if(ay > V) return prefix+'_DOWN';
    if(ay < -V) return prefix+'_UP';
  }
  return null;
}

    function handleAnalog(pad){
      const now = performance.now();
      // Eixos padrão: 0=X(L),1=Y(L),2=X(R),3=Y(R)
      const ldir = dirFromAxes(pad.axes[0]||0, pad.axes[1]||0, 'L');
      const rdir = dirFromAxes(pad.axes[2]||0, pad.axes[3]||0, 'R');
      if(ldir !== lastDirL){
        // Borda: neutro -> direção
        if(lastDirL===null && ldir){ onPressKey(ldir, now); }
        lastDirL = ldir;
      }
      if(rdir !== lastDirR){
        if(lastDirR===null && rdir){ onPressKey(rdir, now); }
        lastDirR = rdir;
      }
    }

    function onPressKey(key, now){
      const metaLabel = ANALOG_LABEL[key] || BUTTONS[key]?.label || key;
      if(!active || !targetKey){
        log(`Entrada: ${metaLabel} (fora de rodada)`);
        return;
      }
      if(key === targetKey){
        const rt = now - showTime;
        results.push(rt);
        updateStats(rt);
        combo++; if(combo>bestCombo){ bestCombo = combo; SFX.record(); showRecordFlash(); }
        updateComboUI();
        feedback.textContent = '✔️ Correto: ' + ms(rt);
        feedback.className = 'pill ok';
        flash('ok'); SFX.ok();
        scheduleNext();
      } else {
        combo = 0; updateComboUI();
        feedback.textContent = `❌ Errado: ${metaLabel}`;
        feedback.className = 'pill err';
        flash('err'); SFX.err();
        if(endOnErrorEl.checked){ endSession('error'); } else { scheduleNext(); }
      }
      targetKey = null; label.textContent='—'; shape.className='shape';
    }

    function showRecordFlash(){
      comboSpecial.style.display='block';
      comboSpecial.textContent = '🏆 Novo Recorde de Combo!';
      comboSpecial.classList.remove('record');
      void comboSpecial.offsetWidth;
      comboSpecial.classList.add('record');
    }

    // --- Teclado (backup) — mantém apenas face buttons ---
    const keyMap = { x:'CROSS', c:'CIRCLE', s:'SQUARE', t:'TRIANGLE' };
    window.addEventListener('keydown', (e)=>{
      if(!kbOnEl.checked) return;
      const mapped = keyMap[e.key];
      if(mapped){ onPressKey(mapped, performance.now()); }
    });

    // --- Leaderboard por nível (LocalStorage) ---
    const LB_KEY = 'reaction-ps-leaderboard-v5-analog';

    function readLB(){
      try{
        const raw = JSON.parse(localStorage.getItem(LB_KEY)||'{}');
        return { easy: raw.easy||[], medium: raw.medium||[], hard: raw.hard||[] };
      }catch{ return { easy:[], medium:[], hard:[] }; }
    }
    function writeLB(data){ localStorage.setItem(LB_KEY, JSON.stringify(data)); }

    function sortR2(a,b){
      if(a.avg!==b.avg) return a.avg - b.avg; // menor é melhor
      if(a.bestCombo!==b.bestCombo) return b.bestCombo - a.bestCombo; // maior é melhor
      return (a.best||Infinity) - (b.best||Infinity);
    }

    function renderLB(){
      const data = readLB();
      const list = (data[lbView]||[]).slice().sort(sortR2).slice(0,5);
      if(!list.length){ lbBody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:var(--muted)">Sem registros ainda</td></tr>'; return; }
      lbBody.innerHTML = list.map((it, i)=>{
        const d = new Date(it.date).toLocaleString();
        const avg = Math.round(it.avg);
        const best = Math.round(it.best);
        return `<tr><td>${i+1}</td><td>${avg} ms</td><td>${best} ms</td><td>x${it.bestCombo}</td><td>${d}</td></tr>`;
      }).join('');
    }

    let lastSavedDate = null;
    function maybeSaveScore(){
      if(!results.length) return; // nada para salvar
      const entry = { avg: mean(results), best: Math.min(...results), bestCombo, date: Date.now(), dur: durSec };
      lastSavedDate = entry.date;
      const data = readLB();
      data[level] = (data[level]||[]);
      data[level].push(entry);
      data[level].sort(sortR2);
      data[level] = data[level].slice(0,5); // mantém top 5 por nível
      writeLB(data);
      renderLB();
      log(`Salvo no Leaderboard (${LEVELS[level].name}) → Média ${ms(entry.avg)} | Melhor ${ms(entry.best)} | Combo x${entry.bestCombo}`, 'ok');
    }

    btnResetLB.addEventListener('click', ()=>{
      if(confirm(`Zerar ranking do nível ${LEVELS[lbView].name}?`)){
        const data = readLB();
        data[lbView] = [];
        writeLB(data);
        renderLB();
      }
    });

    // Troca de abas do leaderboard
    lbTabs.forEach(tab=>{
      tab.addEventListener('click', ()=>{
        lbTabs.forEach(t=>t.classList.remove('active'));
        tab.classList.add('active');
        lbView = tab.dataset.lb;
        renderLB();
      });
    });

    // Dificuldade: T1 (só pode trocar parado)
    levelSelect.addEventListener('change', ()=>{
      if(active){
        alert('Pare o jogo para trocar o nível. (T1)');
        levelSelect.value = level; return;
      }
      level = levelSelect.value;
      applyLevelSettings();
    });

    // Fim de sessão – overlay
    btnRestart.addEventListener('click', ()=>{ overlay.style.display='none'; start(); });
    btnClose.addEventListener('click', ()=>{ overlay.style.display='none'; });

    // --- UI hooks ---
    btnConnect.addEventListener('click', ()=>{
      log('Pressione qualquer botão no controle agora para registrar.');
      try{ navigator.vibrate && navigator.vibrate(50);}catch{}
    });
    btnStart.addEventListener('click', start);
    btnStop.addEventListener('click', stop);

    // Init
    buildPoolUI();
    applyLevelSettings();
    renderLB();
    (function loop(){ poll(); })();
  </script>
</body>
</html>
